# 스레드보다는 실행자, 태스크, 스트림을 애용하라

## 용어 정리

**1. 스레드(Thread)**

> 프로세스 내에서 실행되는 독립적인 실행 흐름으로, Java에서 Thread 클래스로 표현되며 직접 생성과 관리가 필요한 저수준 API

**2. 실행자(Executor)**

> 작업 제출("무엇을 실행할지")과 실행 방식("어떻게 실행할지")을 분리하는 인터페이스로, 스레드 풀과 작업 큐를 내부적으로 관리하여 개발자가 스레드 관리 부담 없이 작업에 집중할 수 있게 함

**3. 태스크(Task)**

> 실행자에게 제출하는 작업의 단위로, Java에서는 `Runnable`(반환값 없는 작업)과 `Callable`(값을 반환하는 작업) 인터페이스로 표현됨

**4. 스트림(Stream)**

> 데이터 요소의 시퀀스를 함수형으로 처리하는 API로, Java 8에서 도입되었으며 parallel() 메서드를 통해 간단히 병렬 처리 구현 가능

```java
import java.util.concurrent.*;

public class ExecutorExample {
    public static void main(String[] args) throws Exception {
        // 실행자 생성 - 실행 방식 결정 부분
        ExecutorService executor = Executors.newFixedThreadPool(3); // 스레드 3개로 구성된 풀
        
        // 작업(태스크) 정의
        Callable<String> task1 = () -> {
            Thread.sleep(1000);
            return "첫 번째 작업 완료";
        };
        
        Runnable task2 = () -> {
            System.out.println("두 번째 작업 실행 중...");
            // 반환값 없음
        };
        
        // 작업 제출 부분
        Future<String> future = executor.submit(task1); // Callable 태스크 제출
        executor.execute(task2); // Runnable 태스크 제출
        
        // 첫 번째 작업의 결과 가져오기
        String result = future.get();
        System.out.println(result);
        
        // 실행자 종료
        executor.shutdown();
    }
}
```

## Java 5 이전

- 자바 표준 라이브러리에 **스레드 풀**이나 **작업 큐** 관련 고수준 API가 없어 직접 스레드 풀과 작업 큐를 구현했음.

  > **스레드 풀(Thread Pool)**: 미리 생성해 놓은 재사용 가능한 스레드들의 집합. 매번 스레드를 생성/소멸하는 비용을 줄이고, 동시 실행 스레드 수를 제한하여 시스템 자원을 효율적으로 관리함.
  > 
  > **작업 큐(Task Queue)**: 실행할 작업(Runnable/Callable)들이 대기하는 큐. 스레드 풀의 모든 스레드가 사용 중일 때 추가 작업을 저장해두고, 스레드가 가용해지면 큐에서 작업을 꺼내 실행함.

## Java 5 이후

- `java.util.concurrent` 패키지에서 `ExecutorService`, `ThreadPoolExecutor` 등의 고수준 API 제공

  > **스레드 관리 자동화**: 스레드 생성, 재사용, 종료를 자동으로 처리 <br>
  > **작업 큐잉 자동화**: 작업 대기열 관리를 위한 별도 코드 불필요 <br>
  > **스레드 수 제한**: 스레드 수 제한으로 시스템 자원 효율적 관리 <br>
  > **유연한 실행 정책**: 단일 스레드, 고정 크기 풀, 캐시 풀 등 다양한 실행 전략 <br>
  > **라이프사이클 관리**: shutdown(), shutdownNow() 등으로 안전한 종료 관리


## ExecutorService 기능

1. **특정 태스크 완료 대기 (`Future.get` 메서드)**
    - 특정 태스크의 결과가 필요할 때 사용
    - 블로킹 방식으로 작업 완료를 기다림
    - 타임아웃을 설정하여 무한정 대기 방지 가능
2. **태스크 모음 관리 (`invokeAny`, `invokeAll` 메서드)**
    - `invokeAny`: 여러 작업 중 가장 빨리 완료되는 하나의 결과만 필요할 때
    - `invokeAll`: 모든 작업의 결과가 필요할 때
    - 병렬로 여러 서버에 요청하거나, 여러 알고리즘으로 동시에 문제를 해결할 때 유용
3. **실행자 서비스 종료 대기 (`awaitTermination` 메서드)**
    - 정상적인 종료 처리를 위해 사용
    - 지정된 시간 동안 대기하며, 시간 내 종료되면 true 반환
    - 애플리케이션 종료 시 실행자 서비스 정리에 필수적
4. **완료된 태스크 결과 순차적 처리 (`ExecutorCompletionService`)**
    - 작업 완료 순서대로 결과를 처리하고 싶을 때 유용
    - 실행 시간이 다양한 여러 작업의 결과를 처리할 때 효율적
    - 웹 크롤링, 여러 서비스 병렬 호출 등에 적합
5. **예약 실행 (`ScheduledThreadPoolExecutor`)**
    - 주기적인 작업이나 지연 실행 작업에 적합
    - `scheduleAtFixedRate`: 정확한 주기로 실행 (작업 시간이 주기보다 길면 작업들이 연속 실행)
    - `scheduleWithFixedDelay`: 이전 작업 완료 후 지정된 지연 시간 후 실행

## Java 7

- 실행자 프레임워크가 포크-조인(fork-join)태스크를 지원하도록 확장

  > **포크-조인**: 분할 정복 알고리즘을 병렬로 실행하기 위한 프레임워크

## 포크-조인(fork-join)

1. **용어**
    - 포크(Fork): 큰 태스크를 작은 하위 태스크로 재귀적으로 분할
    - 실행: 충분히 작아진 태스크를 실행
    - 조인(Join): 모든 하위 태스크의 결과를 합쳐 최종 결과 생성

2. **주요 구성 요소**
    - `ForkJoinPool`:

        - 포크-조인 태스크를 실행하기 위한 특수한 실행자 서비스
        - 작업 훔치기(work-stealing) 알고리즘 사용
        - 모든 스레드가 바쁘게 유지되도록 보장


    - `ForkJoinTask`:

        - 포크-조인 풀에서 실행할 수 있는 태스크의 기본 클래스
        - 주요 하위 클래스:

            - `RecursiveAction`: 반환값이 없는 태스크
            - `RecursiveTask<V>`: 결과값을 반환하는 태스크

3. **작업 훔치기(Work-Stealing) 알고리즘**
    - 각 스레드는 자신의 작업 큐를 가짐
    - 자신의 큐가 비면 다른 스레드의 큐에서 작업을 "훔침"
    - 모든 스레드의 작업 부하를 균등하게 유지
    - 효율적인 CPU 활용으로 이어짐

4. **장점**
    - 높은 성능: 멀티코어 프로세서를 효율적으로 활용
    - 자동 부하 분산: 작업 훔치기로 모든 스레드 활용 최적화
    - 간결한 API: 복잡한 병렬 알고리즘을 비교적 간단히 구현
    - 확장성: 코어 수에 맞게 자동으로 확장

## Java 8

- 병렬 스트림은 내부적으로 포크-조인 프레임워크를 사용

## 결론

> 고수준 동시성 유틸리티를 사용하면 동시성 프로그래밍이 쉬워지고 안전해진다. 가능하면 직접 스레드를 다루는 것보다 실행자, 태스크, 스트림과 같은 추상화된 API를 사용해라. 실행자 프레임워크는 작업 제출과 실행을 분리하고, 스레드 풀과 작업 큐를 자동으로 관리해준다. 태스크는 작업 단위를 구조화하며, 스트림 API는 데이터 병렬 처리를 간소화함. 이를 통해 코드의 가독성, 유지보수성, 안정성이 향상되고, 멀티코어 환경에서 더 효율적인 프로그램을 작성할 수 있다.