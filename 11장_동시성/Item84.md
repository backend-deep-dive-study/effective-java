# 프로그램의 동작을 스레드 스케줄러에 기대지 말라

- 스레드는 운영체제의 스레드 스케줄러에 의해 운영된다. 따라서 프로그램의 동작을 스레드 스케줄러에 좌지우지돼서는 안 된다.

- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

- 좋은 프로그램을 작성하기 위해서는 스레드의 평균 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다.

    - 그래야 스레드 스케줄러가 고민할 거리가 줄어들기 때문이다.

    - 실행 준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록 만들자.

- 실행 가능한 스레드의 수와 전체 스레드 수는 구분해야 한다.

    - 전체 스레드 수는 더 많을 수 있고, 대기 중인 스레드는 실행 가능하지 않다.

- 실행 가능한 스레드를 적게 유지하는 방법

    - 스레드가 유용한 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하는 것이다.
    - **스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안 된다.**

        - 스레드 풀 크기를 적절히 설정하고 작업은 짧게 유지하면 된다.

- 스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 안 된다.

    - 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다.

    - 바쁜 대기는 스레드 스케줄러의 변덕에 취약할 뿐 아니라, 프로세서에 큰 부담을 주게 된다.

    ```java
    //나쁜 코드 - CountDownLatch의 바쁜 대기 버전
    public class SlowCountDownLatch { 
        private int count;

        public SlowCountDownLatch(int count) {
           if (count < 0)
                throw new IlIegalArgumentException(count + " < 0");
            this.count = count;
        }

        //바쁜 대기 코드드
        public void await() {
            while (true) { 
                synchronized(this) { 
                    if (count = 0) 
                        return;
                }
            }
        }

        public synchronized void countDown() { 
            if (count != 0) 
                count—;
        } 
    }
    ```

    - 이 스레드랑 자바의 CountDownLatch와 비교해보니 약 10배 느렸다.

- 특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해서 간신히 돌아가는 프로그램을 보더라도 **Thread.yield를 써서 문제를 고쳐보려는 유혹을 떨쳐내자.**

    - 증상이 어느 정도는 호전될 수도 있지만 이식성은 그렇지 않을 것이다.

    - **Thread.yield는 테스트할 수단도 없다.**

- 스레드 우선순위를 조절하는 방법도 있지만, 비슷하게 위험이 존재한다.

    - 자바에서 이식성이 가장 나쁜 특성에 속한다.

    - 스레드 몇 개의 우선순위를 조율해서 애플리케이션의 반응 속도를 높이는 것 도 일견 타당할 수 있으나, 정말 그래야 할 상황은 드물고 이식성이 떨어진다.

    - 심각한 응답 불가 문제를 스레드 우선순위로 해결하려는 시도는 좋지 않다.

        - 진짜 원인을 찾아 수정하기 전까지 같은 문제가 반복해서 터져 나올 것이다.