# Serializable을 구현할지는 신중히 결정하라

### Serializable을 구현하면 릴리스한 뒤 수정하기 어려움

- 클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 됨
    - 직렬화 형태도 영원히 지원해야 함
- 커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용할 경우
    - 직렬화 형태는 적용 당시 클래스의 내부 구현 방식에 종속됨
    - 기본 직렬화 형태에서는 클래스의 private, package-private 인스턴스 필드들마저 API로 공개 (→ 캡슐화 깨짐)
- 클래스 내부 구현을 수정하면 원래 직렬화 형태와 달라짐
    - 구버전 인스턴스를 직렬화하고, 신버전 클래스로 역직렬화하면 오류 발생
- 원래 직렬화 형태를 유지하면서 내부 표현 변경
    - ObjectOutputStream.putFields, ObjectInputStream.readFields 사용
    - 어렵고 소스코드에 오점이 생김
        - 예전 직렬화 필드 이름을 계속 소스 코드에 남겨야 하므로 과거 구현의 흔적이 코드에 남음
        - 내부 필드명은 바뀌었지만 직렬화 시 키값은 여전히 과거 명칭을 유지해야 하므로 코드 일관성이 무너짐
        - `serialVersionUID`를 명시하지 않거나 잘못 관리할 경우 이전 버전과의 호환이 깨질 위험

### 직렬화가 클래스 개선을 방해하는 경우

#### 스트림 고유 식별자 (serial version UID)

- 모든 직렬화된 클래스는 고유 식별 번호 받음
- static final long 필드
- 명시하지 않으면 시스템이 런타임에 암호 해시 함수를 적용해 자동으로 생성
    - 값 생성에는 클래스 이름, 구현한 인터페이스들, 컴파일러가 자동으로 생성해 넣은 것을 포함
    - → 후에 수정이 발생하면 serial version UID 값도 변함
- ⇒ 자동 생성되는 값에 의존하면 쉽게 호환성이 깨져 런타임 InvalidClassException 발생

#### 버그와 보안 구멍이 생길 위험이 커짐

- 객체는 생성자를 사용해 만드는 게 기본
    - 직렬화 = 언어의 기본 메커니즘을 우회하는 객체 생성 기법
- 역직렬화는 일반 생성자의 문제가 그대로 적용되는 **숨은 생성자**
    - 역직렬화는 전면에 드러나지 않음 → 일반 생성자를 거치지 않고 생성
- 기본 역직렬화 사용 시 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출

#### 해당 클래스의 신버전을 릴리스할 때 테스트할 것 증가

- 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그 반대도 가능한지 검사 필요
    - 양방향 직렬화/역직렬화 모두 성공
    - 원래의 객체를 충실히 복제해 내는지 확인 필요
- 테스트할 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례하여 증가

### Serializable 구현 여부는 가볍게 결정할 사안이 아님

- Serializable 구현에 따르는 비용이 적지 않음
    - 클래스 설계 시 이득과 비용을 잘 계산해야 함
- ex) BigInteger와 Instant 같은 **값 클래스**와 컬렉션 클래스들은 Serializable을 구현하고, 스레드 풀처럼 **동작하는 객체를 표현하는 클래스**들은 Serializable을 구현하지 않음

### Serializable을 구현하면 안되는 경우

#### 상속용으로 설계된 클래스와 인터페이스

- 클래스를 확장하거나 인터페이스를 구현하는 쪽에 위험성 그대로 전이
    - 해당 규칙을 어겨야 하는 상황도 존재
- Serializable을 구현한 클래스만 지원하는 프레임워크 사용 시 필수
    - ex-1) Throwable: 서버가 RMI를 통해 클라이언트로 예외를 보내기 위해 구현
    - ex-2) Component: GUI를 전송하고 저장하고 복원하기 위해 구현
- 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능할 경우 주의 사항
    - 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 하위 클래스에서 finalize 메서드 재정의하지 못하게 해야 함
    - 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 아래와 같은 메서드 추가 → 불변식 위반을 사전에 차단
    
    ```java
    private void readObjectNoData() throws InvalidObjectException {
        throw new InvalidObjectException("스트림 데이터가 필요합니다.");
    }
    ```

### Serializable을 구현하지 않기로 할 때 주의 사항

- 상속용 클래스인데 직렬화를 지원하지 않으면 하위 클래스에서 직렬화 지원 시 부담 증가
- 이런 클래스를 역직렬화하려면 상위 클래스는 매개변수가 없는 생성자 제공해야 함
- 매개변수가 없는 생성자를 제공하지 않으면 하위 클래스에서는 직렬화 프록시 패턴 사용

### 내부 클래스는 직렬화를 구현하지 말아야 함

- 바깥 인스턴스의 참조와 유효 범위 안의 지역변수를 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가됨
    - 해당 필드들이 클래스 정의에 어떻게 추가되는지 정의되지 않음
- ⇒ 내부 클래스에 대한 기본 직렬화 형태는 분명하지 않음
- 정적 멤버 클래스는 Serializable 구현해도 됨
