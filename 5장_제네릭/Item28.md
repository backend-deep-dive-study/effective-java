# 배열보다는 리스트를 사용하라

### 배열와 제네릭 타입의 차이
1. 배열은 공변이지만 제네릭은 불공변이다. 
  - `Sub`가 `Super`의 하위타입이면 `Sub[]`가 `Super[]`의 하위타입이다.
    - 즉, 배열은 상위 타입 배열 변수에 하위 타입 배열을 저장할 수 있다.
    - 하지만, 런타임에 타입 불일치가 발생하면 `ArrayStoreException`이 발생할 위험이 있다.
    
  - 그러나 `List<Sub>`와 `List<Super>`의 하위 타입이 아니다.
    - 컴파일 타임에 타입 불일치를 방지하기 위해 제네릭은 불공변이다.
  - 배열의 경우 실수를 했을 때 런타임에 알지만 리스트는 컴파일 할 때 알 수 있다. 
  ```java
  Super[] arr = new Sub[] // 공변
  List<Super> list = new ArrayList<Sub>() // 불공변, 컴파일 에러
  ```

2. 배열은 실체화된다.
  - 배열의 타입 정보는 런타임에도 확인할 수 있다. 
  - 제네릭의 타입 정보는 런타임에 소거된다. 즉, 컴파일타임에만 타입을 검사한다. (제네릭 지원 전의 레거시 코드 때문)
  => 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다. 
  ```java
  // 모두 컴파일 에러가 뜸
  new List<E>[] // 제네릭 타입 배열
  new List<String>[] // 매개변수화 타입 배열
  new E[] // 타입 매개변수 배열
  ```

### 제네릭 배열을 만들지 못하는 이유
  - 타입 안전하지 않다!!
  - 컴파일러가 자동 생성한 형변환 코드에서 런타임에 `ClassCastException` 발생 가능
  ```java
  List<String>[] stringLists = new List<String>[1];
  List<Integer> intList = List.of(42);
  Object[] objects = stringLists;
  objects[0] = intList;
  String s = stringLists[0].get(0); // 꺼내온 원소가 Integer이므로 String으로 형 변환 할 때 런타임에 ClassCastException이 발생
  ```

### 실체화 불가 타입
  - `E`, `List<E>`, `List<String>` : 런타임에 컴파일 타임보다 타입 정보를 적게 가짐
  - 비한정적 와일드카드 타입 : 매개변수화 타입 중 실체화될 수 있는 타입
  - 제네릭 컬렉션에서 자신의 원소 타입을 담은 배열을 반환하는 게 보통은 불가능
  - 제네릭 타입과 가변인수 메서드를 함께 쓰면 경고 발생
    ```java
    public static <T> void unsafeMethod(T... elements) {
    Object[] array = elements;
    array[0] = 42;  // String 타입이어야 하는데 Integer가 들어감 -> 런타임 오류 발생 가능
    }
    ```
  - `@SafeVarargs` 애너테이션으로 대처 가능
  => 배열 형변환 시 오류나 경고가 뜨는 경우 `E[]` 대신 `List<E>` 사용해 해결

### 결론 : 배열은 런타임에는 타입 안전하지만 컴파일 타입에 그렇지 않으니 컴파일 오류를 만나면 배열을 리스트로 대체해보자!
1. 타입 안정성: 배열은 런타임에 타입 검사를 하지만, 리스트는 컴파일 타임에 타입을 체크하여 오류를 방지한다.
2. 실체화 문제 회피: 제네릭 배열을 만들 수 없으므로, 리스트를 사용해야 한다.
3. 가변인수와 호환성: 제네릭과 가변인수를 함께 사용할 때 발생하는 문제를 피할 수 있다.

## 부록

### 실체화
  - 실체화 : 컴파일 후에도 타입 정보가 남아 있는 것
  - 실체화 불가 : 컴파일 후 타입 정보가 사라지는 것
  - 제네릭 타입은 타입 소거 때문에 실체화할 수 없다.

### 가변인수
  - 매개변수로 들어오는 값의 개수와 상관 없이 동적으로 인수를 받아 기능하도록 해주는 문법
  - 메서드 오버로딩으로 처리할 수 있음
  - 내부적으로 배열을 생성해서 사용하는 것과 같기 때문에 배열 타입 매개변수와 혼용할 수 없음
    
