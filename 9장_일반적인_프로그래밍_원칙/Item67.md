# 최적화는 신중히 하라
## 최적화 전에 기본 원칙부터 충실히
- 성능보다 먼저 고려해야 할 것은 견고한 구조
- 좋은 프로그램은 일반적으로 성능도 개선하기 용이
  - 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있음
## 설계 단계에서 유의할 점
- 성능을 해치는 아키텍처 결함은 최적화로 해결 불가능할 수 있음
  - 완성된 설계의 기본 틀을 변경하려다 보면 유지보수하거나 개선하기 어려운 꼬인 구조의 시스템이 만들어지기 쉽기 때문
- 완성 후 변경하기 가장 어려운 설계 요소
  - API
  - 네트워크 프로토콜
  - 영구 저장용 데이터 포맷 등
  - ex) java.awt.Component 클래스의 getSize() 메서드가 불변 객체가 아닌 Dimension을 반환 -> 수많은 불필요한 객체 생성
## API 설계와 성능
- 불필요한 방어적 복사 유발 방지를 위해 가변 객체 반환 금지
- 성능을 제약하는 상속보다는 컴포지션 이용
- 구현타입 보다는 인터페이스 사용
## 최적화의 올바른 순서
1. 완성도 높은 코드 작성
2. 성능 문제 발생 시 최적화 고려
3. 항상 최적화 전후로 성능 측정
4. 프로파일링 도구를 활용하여 병목 지점 파악
5. 알고리즘 점검
6. 필요시 하드웨어/플랫폼별로 각각 측정
## 성능 측정이 중요한 이유
- 느릴 거라 짐작했던 부분이 실제 병목이 아닐 수 있음
- 대부분 실행 시간(90%)은 일부 코드(10%)에서 소비됨
- 잘못된 추측은 성능 저하 초래 가능
- Java의 성능 모델은 덜 정교하고 구현 시스템마다 차이가 있음 -> 측정 필수!
## 정리
- 좋은 프로그램을 작성하면서 설계 시 성능을 고려할 것
- 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷
- 성능을 측정하여 필요한 경우만 최적화 할 것
## 부록
### 상속과 컴포지션
| 항목 | 상속 (Inheritance) | 컴포지션 (Composition) |
|--------|------|----------|
관계 | is-a (상위 타입) | has-a (내부 위임)
유연성 | 낮음 | 높음
캡슐화 | 약함 (내부 구현 노출) | 강함 (구현 은닉 가능)
유지보수 | 어렵다 | 용이하다
성능 제약 | 상위 클래스 성능/설계에 종속 | 더 나은 구현체로 교체 가능
### 실제 Componet의 getSize()
```java
public Dimension getSize() {
    return size();
}

public Dimension size() {
    return new Dimension(width, height); // 매번 새로운 Dimension 객체 반환
}
```
