# 상속보다는 컴포지션을 사용하라

## 상속의 문제

### 상속이란?
- 한 클래스가 다른 클래스의 기능을 물려받아 확장하는 방식
- 코드 재사용과 확장성을 높이기 위해 사용되지만, 구현 상속은 캡슐화를 깨트리고 결합도를 높이는 문제가 있음

> **여기서의 상속이란?**  
> 한 클래스가 다른 클래스의 구현을 상속받아 재사용하는 경우  
> 클래스가 다른 클래스를 확장하는 **구현 상속** (인터페이스 상속 X)

### 구현 상속의 문제점
- **캡슐화가 깨짐**: 상위 클래스의 내부 구현이 하위 클래스에 노출됨
- **강한 결합도**: 상위 클래스가 변경되면 하위 클래스도 영향을 받을 가능성이 큼
- **유지보수 어려움**: 새로운 기능 추가 시 예상치 못한 오류 발생 가능
- **리리스 위험**: 상위 클래스의 업데이트가 하위 클래스의 오동작을 유발할 수 있음
- **유연성 부족**: 다중 상속을 허용하지 않는 경우 확장이 제한적

## 상속의 문제를 해결하는 방법

### 컴포지션 (Composition)
기존 클래스를 직접 확장하는 대신, 새로운 클래스 내부에 기존 클래스의 인스턴스를 필드로 포함하는 방식

#### 컴포지션의 장점
- **캡슐화 유지**: 기존 클래스의 세부 구현이 숨겨지며 변경이 외부 클래스에 영향을 주지 않음
- **낮은 결합도**: 한 클래스의 변경이 다른 클래스에 영향을 최소화
- **다중 컴포지션 가능**: 여러 클래스를 조합하여 유연하게 동작 확장 가능
- **새로운 기능 확장 용이**: 기존 클래스를 변경하지 않고도 새로운 기능 추가 가능

### 전달(Forwarding)
- 새 클래스의 인스턴스 메서드는 기존 클래스의 대응하는 메서드를 호출하여 결과 반환 (전달 메서드)
- 기존 클래스의 내부 구현 변경에도 영향받지 않음

### 컴포지션과 전달을 활용한 예제

```java
class Engine {
    public void start() {
        System.out.println("Engine starting...");
    }
}

class Car {
    private final Engine engine; // Engine 객체를 필드로 포함 (has-a 관계)

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void startCar() {
        engine.start(); // 내부 객체의 메서드를 호출하는 "전달(forwarding)"
        System.out.println("Car is moving...");
    }
}

public class Main {
    public static void main(String[] args) {
        Engine engine = new Engine();
        Car car = new Car(engine);
        car.startCar();
    }
}
```

## 위임(Delegation)
- **컴포지션 + 전달(forwarding)의 조합**
- 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우 위임에 해당
- 콜백 프레임워크에서 SELF 문제 발생 가능 (자기 자신의 참조를 넘겨 내부 객체를 호출하는 문제)

## 상속을 사용해도 괜찮은 경우
- **"is-a" 관계**가 명확할 때
- **부모 클래스의 동작을 변경하지 않고 그대로 사용할 때**
- **템플릿 메서드 패턴(Template Method Pattern)과 같은 패턴을 사용할 때**

### 컴포지션을 고려해야 하는 경우
- **부모 클래스의 일부 동작만 사용하려고 할 때**
- **부모 클래스의 변경이 하위 클래스에 영향을 주지 않게 하고 싶을 때**
- **기능 확장을 유연하게 하고 싶을 때**

## 결론
> "상속은 신중하게 사용하고, 가능하면 컴포지션을 우선 고려하라!"  
> "구현 상속(클래스 상속)은 캡슐화를 깨트리고 유지보수를 어렵게 만든다."  
> "컴포지션을 사용하면 유연하고 확장 가능한 코드를 작성할 수 있다."

### **따라서, 코드의 재사용성과 확장성을 고려할 때는 "컴포지션 + 전달(Forwarding)"을 활용하자!**

---

## 📌 부록: 상속 vs 컴포지션 비교

| 항목 | 상속 (Inheritance) | 컴포지션 (Composition) |
|------|------------------|------------------|
| 관계 | "is-a" 관계 | "has-a" 관계 |
| 캡슐화 | 깨짐 (부모 클래스 구현이 노출됨) | 유지됨 (내부 구현 숨김) |
| 결합도 | 높음 (부모 클래스 변경 시 영향 큼) | 낮음 (독립적 변경 가능) |
| 유지보수 | 어렵고 리스크 있음 | 용이하고 안전함 |
| 다중 확장 | 다중 상속이 불가능한 경우 제한적 | 여러 클래스를 조합하여 유연하게 확장 가능 |
| 사용 예시 | 부모 클래스와 동일한 동작을 유지할 때 | 유연한 기능 확장이 필요할 때 |

