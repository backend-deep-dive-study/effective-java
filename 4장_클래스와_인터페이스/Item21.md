# 인터페이스는 구현하는 쪽을 생각해 설계해라

- 자바 8 전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드 추가 불가
    - 인터페이스에 메서드 추가 시 컴파일 오류
    - 기존 구현체에 메서드가 있을 경우 오류 X → 가능성 희박
- 자바 8에 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드 추가
    - 위험이 완전히 해결X

### 디폴트 메서드 선언 시 문제

- 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현 사용
    - 구현 클래스와 합의 없이 추가됨
- 기존 구현체들과 매끄러운 연동X
    - 자바 7까지 인터페이스에 새로운 메서드 추가를 고려하지 않음

⇒ 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드 작성은 어려움

### Collection의 removeIf 디폴트 메서드

- 주어진 boolean 함수가 true를 반환하는 모든 원소 제거
    - predicate(프레디키트) : boolean 함수
- default 구현 : 모든 원소를 파라미터로 프레디키트 호출 → true 반환 시 remove 매서드 호출

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext();){
        if(filter.test(it.next())){
            it.remove();
            result = true;
        }
    }
    return result;
}
```

- 범용적으로 잘 작성된 예시
- 현존하는 모든 Collection 구현체와 잘 어우러지는 것은 아님
    - SyncronizedCollection : 컬렉션 대신 클라이언트가 제공한 객체로 락을 거는 능력 제공 → 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능 위임하는 wrapper 클래스
    - removeIf 사용X → 동기화에 관해 아무것도 알 수 없어 락 객체 사용불가
    - 여러 스레드가 공유하는 환경에서 removeIf 호출 시 예외 발생

### 디폴트 메서드 (동기화) 문제 해결

- 디폴트 메서드 재정의
    - removeIf 재정의
- 디폴트 메서드 호출 전 필요 작업 수행
    - removeIf를 호출하는 다른 디폴트 메서드들(removeAll, retainAll 등)이 **동기화 되지 않은 디폴트 구현을 호출**할 가능성 있음
    - 디폴트 구현 호출 전에 동기화 (재정의한 버전을 호출하도록)

자바 플랫폼에 속하지 않은 제3의 기존 컬렉션 구현체들은 아직 수정되지 않음

### 디폴트 메서드의 단점

- 컴파일에 성공하더라도 기존 구현체에 **런타임 오류** 발생시킬 수 있음
    - 디폴트 메서드 추가 시 기존 코드에 영향↑
    - 디폴트 메서드로 새 메서드 추가 지양

### 디폴트 메서드의 장점

- 새로운 인터페이스 생성 시 표준적인 메서드 구현을 제공하는데 유용
- 인터페이스를 더 쉽게 구현해 활용할 수 있도록 함

### 디폴트 메서드 주의 사항

- 디폴트 메서드는 인터페이스에서 메서드 제거, 기존 메서드 시그니처를 수정하는 용도X
    - 이렇게 인터페이스 변경 시 클라이언트 망가짐

### 인터페이스 설계 주의

- 기존 인터페이스에 새로운 디폴트 메서드 추가 시 위험 발생
    - 어떤 위험인지 명확히 알 수 없어 곤란

### 인터페이스 테스트

- 새로운 인터페이스의 경우 릴리스 전 반드시 테스트
    - 서로 다른 방식으로 최소 3개 구현 ~~(이전 아이템에 인터페이스 다른 사람이 구현하라고 했던..)~~
    - 다양한 클라이언트 생성 (해당 인터페이스를 여러 상황에서 구현하기 위해)
- 테스트 과정에서 결함 찾기
- 릴리스 후에도 수정하는 게 가능한 경우가 있으나 그 가능성에 기대지 않기
