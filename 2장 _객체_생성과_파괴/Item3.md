# private 생성자나 열거 타입으로 싱글턴임을 보증하라	

### 싱글턴
- 정의 : 인스턴스를 오직 하나만 생성할 수 있는 클래스
- 필요성 : 로그, 쓰레드 풀, 윈도우 관리자 등 여러 객체를 관리하는 역할을 하는 경우 하나의 인스턴스가 바람직

### 싱글턴의 단점
- 클라이언트를 테스트하기가 어려움 -> mock으로 대체할 수 없기 때문
- 모듈 간 의존성이 높아짐
- SOLID 원칙에 위배되는 사례가 많음 (단일 책임 원칙, 개방폐쇄 원칙 등)

### 싱글턴을 만드는 방식
- 생성자를 private으로 설
- public static 멤버 하나를 통해 인스턴스에 접근
1) public static + final
   ```
   public static final Movie movie = new Movie();
   private Movie() {...};
   ```
   - private 생성자는 초기화할 때 딱 한 번만 호출됨
   - 예외를 방지하기 위해 두 번째 객체가 생성될 때 예외를 던질 수 있음
   - 클래스가 싱글턴임이 API에 드러남 -> .final이므로 다른 객체를 참조할 수 없기 때문
2) 정적 팩토리 메서드 제공
   ```
   private static final Movie movie = new Movie();
   private Movie() {...};
   public static Movie getInstance() {return movie;}
   ```
   - 항상 같은 객체의 참조를 반환함
   - API를 바꾸지 않고 싱글턴이 아니게 변경할 수 있음
   - 정적 팩토리를 제네릭 싱글턴 팩토리로 만들 수 있음
   - 정적 팩토리의 메서드 참조를 공급자로 사용할 수 있음
3) 열거 타입 방식
   ```
   public enum Movie {
     movie;
   }
   ```
  - 간결, 인스턴스 중복을 막아줌
  - 직렬화를 따로 설정하지 않아도 됨
  - Reflection을 통해 싱글턴이 파괴되지 않는다는 장점!
  - Enum 이외의 클래스를 상속해야 한다면 사용할 수 없음

### 싱글턴 클래스의 직렬화
  - public static final + 정적 팩토리 방식에서 필요!
   -> 아니면 역직렬화마다 새로운 인스턴스가 만들어짐
1) 모든 인스턴스 필드를 일시적(transient)이라 선언
2) readResolve 메서드 제공

### 결론 및 느낀점
- 싱글턴을 만드는 가장 바람직한 방법 = 원소가 하나뿐인 열거 타입!!
- 프레임워크의 도움을 받으면 싱글톤 패턴의 문제점을 보완할 수 있다. -> 평범한 객체도 싱글턴으로 존재할 수 있음!
- 하지만 상황에 맞게 사용하는 것이 필요하다. 열거 타입 방식이 Enum을 상속하지 않을 때나 리소스가 큰 경우에는 정적 팩토리 방식이 적절할 수 있다.
