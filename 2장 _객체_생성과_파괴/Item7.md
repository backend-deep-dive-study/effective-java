# 다 쓴 객체 참조를 해제하라

### 메모리 관리에 대한 오해
- 자바의 가비지 컬렉터가 있다고 해서 메모리 관리에 신경 쓰지 않아도 된다는 것은 아님. 
### 메모리 누수 문제
1. **예시 (책 인용): Stack 클래스에서 발생하는 메모리 누수**
- pop() 메서드에서 스택에서 객체를 꺼낼 때 해당 참조를 null 처리하지 않으면 메모리 누수 발생
- 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않음
2. **해결책**
``` java
public Object pop() {
  if (size == 0)
    throw new EmptyStackException();
  Object result = elements[--size];
  elements[size] = null; // 다 쓴 참조 해제
  return result;
}
```
- 다 쓴 참조(obsolete reference)란 **문자 그대로 앞으로 다시 쓰지 않을 참조.**
- 위 코드에서 elements 배열의 '활성 영역' 밖의 참조들이 모두 해당 (활성 영역은 **인덱스가 size보다 작은 원소들로 구성**)
3. **null 처리의 이점**
- 다 쓴 참조를 해제하여 가비지 컬렉터가 회수할 수 있게 함
- 실수로 해당 참조를 사용할 경우 NullPointerException을 즉시 발생시켜 오류를 조기에 발견

### 메모리 누수 주요 원인
1. **자기 메모리를 직접 관리하는 클래스**
- 스택처럼 자체 메모리 풀(배열, 리스트 등)을 관리하는 클래스
- 비활성 영역의 객체 참조를 명시적으로 null 처리해야 함

2. **캐시**
- 객체 참조를 캐시에 넣고 잊어버리는 경우 메모리 누수 발생
- 해결책
    - WeakHashMap 사용 (키를 약한 참조로 저장)
    - 시간에 따라 엔트리 가치를 떨어뜨리는 방식 활용
    - 백그라운드 스레드로 주기적 청소
    - LinkedHashMap의 removeEldestEntry 메서드 활용
3. **리스너와 콜백**
- 등록만 하고 해지하지 않으면 계속 쌓이는 문제
- 약한 참조(weak reference)로 저장하여 해결

### 정리
- 메모리 누수는 겉으로 드러나지 않아 오랫동안 발견되지 않을 수 있음
- 철저한 코드 리뷰나 힙 프로파일러 같은 도구로 발견 가능
예방법을 익히는 것이 중요
- 모든 객체를 일일이 null 처리할 필요는 없으며, 변수의 범위를 최소화하는 것이 가장 좋은 방법
- null 처리는 스택과 같이 자체 메모리 풀을 관리하는 클래스에서 주로 필요

### 느낀점
- 실제 개발 과정에서는 아직 메모리 누수에 대한 문제를 직접 마주친 적은 없었지만, 이번 학습을 통해 어떤 곳에서 실질적으로 메모리 누수가 발생하고 있는지를 파악할 수 있었습니다.
- 이 지식을 바탕으로 앞으로의 프로젝트에서는 잠재적인 메모리 누수 문제를 예방해야겠습니다.

## 부록
### 가비지 컬렉터는 언제 작동하는가?
    1. 힙 메모리가 임계치에 도달할 때
       - JVM의 힙 메모리가 특정 임계치에 도달하면 가비지 컬렉션이 트리거됨. 
    2. 명시적 호출 시
       - System.gc()를 호출하면 가비지 컬렉션을 요청할 수 있지만, 실행 보장은 없음(힌트일 뿐!) 
    3. JVM의 결정에 따라
       - JVM은 메모리 사용량, CPU 사용량 등을 고려하여 자체적으로 가비지 컬렉션 시기를 결정함. 
    4. 객체가 도달 불가능해질 때
       - 어떤 객체에 대한 모든 참조가 제거되면, 해당 객체는 가비지 컬렉션 대상이 됨. 단, 실제 메모리 회수 시점은 위 요인들에 따라 결정됨. 
### WeakHashMap이란?
- 키를 약한 참조(Weak Reference)로 저장하는 HashMap의 변형
  1. 약한 참조 특성
     - 키 객체를 참조하는 다른 강한 참조가 없으면 가비지 컬렉션 대상이 됨.
  2. 자동 제거 기능
     - 가비지 컬렉션이 실행되면 더 이상 사용되지 않는 키와 해당 값이 자동으로 맵에서 제거됨.
    3. 사용 사례
       - 캐시 구현 : 객체가 다른 곳에서 참조되는 동안만 캐시에 유지
       - 등록-해제 패턴 단순화 : 리스너나 콜백에서 명시적 해제 없이 자동 정리 
```java
Map<Key, Value> cache = new WeakHashMap<>();
```
### 힙 프로파일러란?
- 힙 프로파일러는 애플리케이션의 메모리 사용을 분석하고 모니터링하는 도구
- 예시
  - Java VisualVM: JDK에 포함된 시각적 프로파일링 도구
  - Eclipse Memory Analyzer (MAT): 힙 덤프 분석 도구
  - JProfiler: 상용 Java 프로파일링 도구
  - YourKit: 상용 메모리 및 CPU 프로파일러
### 리스너와 콜백이란?
**리스너**
- 특정 이벤트가 발생했을 때 알림을 받기 위해 등록하는 객체.
- 예시
  - 버튼 클릭/데이터 변경/시스템 상태 변화 등의 이벤트를 감지

**콜백**
- 나중에 호출될 것을 목적으로 다른 코드에 전달되는 실행 가능한 코드
- 예시
  - 비동기 작업 완료, HTTP 요청 응답 수신, 타이머 만료 등의 상황에서 실행됨.

**약한 참조로 저장하면 리스너나 콜백을 명시적으로 해제하지 않더라도, 클라이언트가 해당 객체에 대한 참조를 더 이상 가지고 있지 않을 때 자동으로 가비지 컬렉션 대상이 됨.**
